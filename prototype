<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tape Board – compact</title>
    <style>
      :root {
        --bg: #f6f6f6;
        --ink: #111;
        --scotch-1: #e7e6e3;
        --scotch-2: #d8d6d2;
        --bar-h: 88px;
        --tapeW: 80px; /* ↓ 사이즈 줄임 */
        --tapeH: 40px;
        --tapeOpacity: 0.86;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--ink);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          sans-serif;
        overflow: hidden;
      }

      /* 좌측 상단 초기화 버튼 */
      #reset {
        position: fixed;
        top: 12px;
        left: 12px;
        z-index: 20;
        height: 36px;
        padding: 0 12px;
        border-radius: 8px;
        border: 1px solid rgba(0, 0, 0, 0.15);
        background: #fff;
        color: #111;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      }
      #reset:active {
        transform: translateY(1px);
      }

      #board {
        position: relative;
        height: calc(100% - var(--bar-h) - 16px);
        margin: 8px;
        border-radius: 12px;
        overflow: hidden;
        background: #fff;
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.06);
        isolation: isolate;
      }

      /* 입력 바 (옛날 롤 스타일 + 찢김 꼬리) */
      #bar {
        position: fixed;
        left: 12px;
        right: 12px;
        bottom: 8px;
        height: var(--bar-h);
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        z-index: 10;
      }
      .roll {
        flex: 1;
        height: 100%;
        position: relative;
        border-radius: 12px;
        padding: 10px 12px;
        display: flex;
        align-items: center;
        gap: 10px;
        background: linear-gradient(180deg, var(--scotch-1), var(--scotch-2));
        border: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 1px 0 rgba(255, 255, 255, 0.6) inset,
          0 -1px 0 rgba(0, 0, 0, 0.05) inset, 0 8px 16px rgba(0, 0, 0, 0.06);
      }
      .roll:after {
        content: '';
        position: absolute;
        right: -18px;
        top: 8px;
        bottom: 8px;
        width: 32px;
        background: inherit;
        clip-path: polygon(
          0 0,
          60% 8%,
          35% 18%,
          80% 28%,
          30% 40%,
          90% 54%,
          40% 66%,
          96% 78%,
          50% 90%,
          100% 100%,
          0 100%
        );
        box-shadow: inset -6px 0 0 rgba(0, 0, 0, 0.06);
      }

      /* 입력창 자체는 심플, 대신 양옆에 찢김 삼각형(장식) */
      #word {
        flex: 1;
        height: 52px;
        background: #fff;
        border: 1px solid rgba(0, 0, 0, 0.15);
        border-radius: 10px;
        padding: 0 14px;
        font-size: 18px;
        outline: none;
        position: relative;
        z-index: 1;
      }
      #add {
        height: 52px;
        min-width: 96px;
        padding: 0 18px;
        border-radius: 10px;
        border: 1px solid rgba(0, 0, 0, 0.25);
        background: #242424;
        color: #fff;
        font-weight: 800;
        cursor: pointer;
      }
      #add:active {
        transform: translateY(1px);
      }

      /* 입력창 장식 삼각형 */
      .input-chip {
        position: absolute;
        background: linear-gradient(180deg, var(--scotch-1), var(--scotch-2));
        opacity: var(--tapeOpacity, 0.8);
        pointer-events: none;
        border-radius: 2px;

        z-index: 0; /* input 아래에 */
      }

      /* 테이프(메모) – 컴팩트 */
      .tape {
        position: absolute;
        width: var(--tapeW);
        height: var(--tapeH);
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        user-select: none;
        cursor: grab;
      }
      .tape .bg {
        position: absolute;
        inset: 0;
        border-radius: 8px;
        border: none;
        background: linear-gradient(180deg, var(--scotch-1), var(--scotch-2));
        box-shadow: 0 1px 0 rgba(255, 255, 255, 0.6) inset,
          0 -1px 0 rgba(0, 0, 0, 0.05) inset, 0 6px 12px rgba(0, 0, 0, 0.06);
        opacity: var(--tapeOpacity, 0.86);
        background-clip: padding-box;
        pointer-events: none;
        z-index: 0;
        mix-blend-mode: multiply;
      }
      .tape .chip {
        position: absolute;
        background: linear-gradient(180deg, var(--scotch-1), var(--scotch-2));
        opacity: var(--tapeOpacity, 0.86);
        pointer-events: none;
        z-index: 1;
        border-radius: 2px;
        mix-blend-mode: multiply;
      }
      .tape .label {
        position: relative;
        z-index: 2;
        padding: 2px 6px;
        font-weight: 900;
        font-size: 13px;
        color: #111;
        text-shadow: 0 1px 0 rgba(255, 255, 255, 0.9);
        max-width: calc(var(--tapeW) - 10px);
        text-align: center;
        overflow-wrap: anywhere;
      }
      .tape.stuck {
        --tapeOpacity: 1;
        filter: drop-shadow(0 1px 0.2px rgba(0, 0, 0, 0.22));
        cursor: default;
      }

      .toast {
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        background: #1f1f1f;
        color: #fff;
        padding: 8px 12px;
        border-radius: 10px;
        font-size: 13px;
        opacity: 0.94;
        z-index: 30;
      }
    </style>
  </head>
  <body>
    <button id="reset" type="button">초기화</button>
    <main id="board" aria-label="보드"></main>

    <section id="bar" aria-label="입력">
      <div class="roll" role="group">
        <input
          id="word"
          type="text"
          placeholder="단어 입력"
          autocomplete="off"
          autocapitalize="none"
          spellcheck="false"
          enterkeyhint="done"
          aria-label="단어 입력"
        />
        <button id="add" type="button">완료</button>
      </div>
    </section>

    <script>
      (function () {
        var board = document.getElementById('board');
        var input = document.getElementById('word');
        var addBtn = document.getElementById('add');
        var roll = document.querySelector('.roll');
        var resetBtn = document.getElementById('reset');
        var LS = 'tape_compact_v1';

        /* ───── utils ───── */
        function cssVar(px) {
          var v = getComputedStyle(document.documentElement)
            .getPropertyValue(px)
            .trim();
          return parseInt(v, 10) || 0;
        }
        var TAPE_W = cssVar('--tapeW'),
          TAPE_H = cssVar('--tapeH');

        function toast(msg) {
          var t = document.createElement('div');
          t.className = 'toast';
          t.textContent = msg;
          document.body.appendChild(t);
          setTimeout(function () {
            if (t && t.parentNode) t.parentNode.removeChild(t);
          }, 1200);
        }

        function snapshot() {
          var arr = [],
            nodes = board.querySelectorAll('.tape');
          nodes.forEach(function (n) {
            arr.push({
              id: n.dataset.id,
              text: n.querySelector('.label').textContent,
              x: parseFloat(n.style.left) || 12,
              y: parseFloat(n.style.top) || 12,
              stuck: n.classList.contains('stuck'),
              opacity:
                parseFloat(
                  getComputedStyle(n).getPropertyValue('--tapeOpacity')
                ) || 0.86,
            });
          });
          return { items: arr };
        }
        function save() {
          try {
            localStorage.setItem(LS, JSON.stringify(snapshot()));
          } catch (e) {}
        }
        function load() {
          try {
            var raw = localStorage.getItem(LS);
            if (!raw) return;
            var data = JSON.parse(raw);
            if (data && data.items) data.items.forEach(spawn);
          } catch (e) {}
        }

        /* ───── dragging ───── */
        function makeDraggable(node) {
          var sx = 0,
            sy = 0,
            ox = 0,
            oy = 0,
            dragging = false,
            pid = null;
          function move(e) {
            if (!dragging) return;
            var dx = e.clientX - sx,
              dy = e.clientY - sy;
            var rB = board.getBoundingClientRect(),
              rN = node.getBoundingClientRect();
            var left = Math.max(6, Math.min(rB.width - rN.width - 6, ox + dx));
            var top = Math.max(6, Math.min(rB.height - rN.height - 6, oy + dy));
            node.style.left = left + 'px';
            node.style.top = top + 'px';
          }
          function up() {
            if (!dragging) return;
            dragging = false;
            try {
              if (pid != null) node.releasePointerCapture(pid);
            } catch (e) {}
            window.removeEventListener('pointermove', move);
            window.removeEventListener('pointerup', up);
            save();
          }
          node.addEventListener(
            'pointerdown',
            function (e) {
              if (node.classList.contains('stuck')) return;
              if (typeof e.button !== 'undefined' && e.button !== 0) return;
              var r = node.getBoundingClientRect(),
                b = board.getBoundingClientRect();
              sx = e.clientX;
              sy = e.clientY;
              ox = r.left - b.left;
              oy = r.top - b.top;
              pid = e.pointerId;
              dragging = true;
              try {
                if (pid != null) node.setPointerCapture(pid);
              } catch (e) {}
              window.addEventListener('pointermove', move, { passive: true });
              window.addEventListener('pointerup', up, { passive: true });
              e.preventDefault();
            },
            { passive: false }
          );
          node.addEventListener('dblclick', function () {
            node.classList.toggle('stuck');
            save();
          });
        }

        /* ───── chips logic (예전 코드 기반, 겹침 방지 업그레이드) ───── */
        function triClip(direction) {
          return direction === 'left'
            ? 'polygon(0% 50%, 100% 0%, 100% 100%)'
            : 'polygon(100% 50%, 0% 0%, 0% 100%)';
        }

        // 균등 분할 기반으로 segment마다 1개 배치 → 서로 겹치지 않음
        function stratifiedNonOverlappingPositions(
          totalHeight,
          count,
          edgePad,
          chipHMax
        ) {
          var usable = Math.max(0, totalHeight - edgePad * 2);
          var segH = usable / count;
          // chip 최대높이가 세그먼트보다 크면 줄여서 겹침 방지
          var HMAX = Math.max(4, Math.min(chipHMax, Math.floor(segH - 4)));
          var arr = [];
          for (var i = 0; i < count; i++) {
            var segTop = edgePad + i * segH;
            var segBottom = edgePad + (i + 1) * segH;
            var hh = 6 + Math.floor(Math.random() * Math.max(1, HMAX - 6 + 1));
            var center =
              segTop + segH / 2 + (Math.random() * segH * 0.25 - segH * 0.125); // 약간 흔들기
            var top = Math.round(
              Math.min(segBottom - hh, Math.max(segTop, center - hh / 2))
            );
            arr.push({ top: top, height: hh });
          }
          return arr;
        }

        function addRandomChipsNoOverlap(tapeEl) {
          var h = TAPE_H;
          var countLeft = 4 + Math.floor(Math.random() * 3); // 4~6
          var countRight = 4 + Math.floor(Math.random() * 3); // 4~6
          var edgePad = 4; // 위아래 여백
          var W_MIN = 6,
            W_MAX = 12; // 폭은 여전히 랜덤
          var chipHMax = 14; // 상한. 실제는 세그먼트로 다시 제한됨

          var leftPos = stratifiedNonOverlappingPositions(
            h,
            countLeft,
            edgePad,
            chipHMax
          );
          var rightPos = stratifiedNonOverlappingPositions(
            h,
            countRight,
            edgePad,
            chipHMax
          );

          function addOne(side, top, hh) {
            var chip = document.createElement('div');
            chip.className = 'chip ' + side;
            var w = W_MIN + Math.floor(Math.random() * (W_MAX - W_MIN + 1));
            // 상하 위치는 세그먼트 내에서 이미 결정됨 → 겹치지 않음
            chip.style.width = w + 'px';
            chip.style.height = hh + 'px';
            chip.style.top = top + 'px';
            chip.style.clipPath = triClip(side);
            if (side === 'left') {
              chip.style.left = -w + 2 + 'px';
            } else {
              chip.style.right = -w + 2 + 'px';
            }
            tapeEl.appendChild(chip);
          }

          leftPos.forEach(function (p) {
            addOne('left', p.top, p.height);
          });
          rightPos.forEach(function (p) {
            addOne('right', p.top, p.height);
          });
        }

        /* ───── 입력창에도 찢김 장식 (예전 decorateInputChips 재현) ───── */
        function decorateInputChips() {
          // 기존 장식 제거
          roll.querySelectorAll('.input-chip').forEach(function (n) {
            n.remove();
          });

          var r = input.getBoundingClientRect();
          var rRoll = roll.getBoundingClientRect();
          var h = r.height;

          var countLeft = 4 + Math.floor(Math.random() * 3); // 4~6
          var countRight = 4 + Math.floor(Math.random() * 3); // 4~6
          var edgePad = 6;
          var chipHMax = 16;
          var W_MIN = 6,
            W_MAX = 12;

          var leftArr = stratifiedNonOverlappingPositions(
            h,
            countLeft,
            edgePad,
            chipHMax
          );
          var rightArr = stratifiedNonOverlappingPositions(
            h,
            countRight,
            edgePad,
            chipHMax
          );

          function addOne(side, seg) {
            var chip = document.createElement('div');
            chip.className = 'input-chip';
            var w = W_MIN + Math.floor(Math.random() * (W_MAX - W_MIN + 1));
            var top = r.top - rRoll.top + seg.top;
            chip.style.width = w + 'px';
            chip.style.height = seg.height + 'px';
            chip.style.top = top + 'px';
            chip.style.clipPath = triClip(side);
            if (side === 'left') {
              chip.style.left = r.left - rRoll.left - (w - 2) + 'px';
            } else {
              chip.style.left = r.left - rRoll.left + r.width - 2 + 'px';
            }
            roll.appendChild(chip);
          }

          leftArr.forEach(function (seg) {
            addOne('left', seg);
          });
          rightArr.forEach(function (seg) {
            addOne('right', seg);
          });
        }

        /* ───── 생성 ───── */
        function spawn(opt) {
          opt = opt || {};
          var v = (opt.text || '').trim();
          if (!v) return null;
          var n = document.createElement('div');
          n.className = 'tape';
          n.dataset.id =
            opt.id ||
            (crypto.randomUUID
              ? crypto.randomUUID()
              : String(Date.now() + Math.random()));
          var x =
            typeof opt.x === 'number'
              ? opt.x
              : Math.random() * (board.clientWidth - (TAPE_W + 40)) + 20;
          var y = typeof opt.y === 'number' ? opt.y : 20;
          n.style.left = x + 'px';
          n.style.top = y + 'px';

          var bg = document.createElement('div');
          bg.className = 'bg';
          var label = document.createElement('span');
          label.className = 'label';
          label.textContent = v;

          n.appendChild(bg);
          addRandomChipsNoOverlap(n); // ← 겹침 방지 버전
          n.appendChild(label);

          board.appendChild(n);
          makeDraggable(n);
          save();
          return n;
        }

        /* ───── submit/reset ───── */
        function submit() {
          var v = input.value.trim();
          if (!v) return;
          var br = document.querySelector('#bar .roll').getBoundingClientRect();
          var b = board.getBoundingClientRect();
          spawn({
            text: v,
            x: Math.random() * (board.clientWidth - (TAPE_W + 40)) + 20,
            y: Math.max(12, br.top - b.top - (TAPE_H + 28)),
          });
          input.value = '';
          input.focus();
          decorateInputChips(); // 입력창 장식 갱신
        }

        addBtn.addEventListener('click', submit);
        input.addEventListener('keydown', function (e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            submit();
          }
        });

        resetBtn.addEventListener('click', function () {
          try {
            localStorage.setItem(LS, JSON.stringify({ items: [] }));
          } catch (e) {}
          board.querySelectorAll('.tape').forEach(function (n) {
            n.remove();
          });
          toast('초기화 완료');
          decorateInputChips();
        });

        // 초기 렌더
        load();
        decorateInputChips();
        window.addEventListener('resize', function () {
          requestAnimationFrame(decorateInputChips);
        });
      })();
    </script>
  </body>
</html>
